### ▶ 删除正在迭代中的列表项

```py
list_1 = [1, 2, 3, 4]
list_2 = [1, 2, 3, 4]
list_3 = [1, 2, 3, 4]
list_4 = [1, 2, 3, 4]

for idx, item in enumerate(list_1):
    del item

for idx, item in enumerate(list_2):
    list_2.remove(item)

for idx, item in enumerate(list_3[:]):
    list_3.remove(item)

for idx, item in enumerate(list_4):
    list_4.pop(idx)
```

**Output:**
```py
>>> list_1
[1, 2, 3, 4]
>>> list_2
[2, 4]
>>> list_3
[]
>>> list_4
[2, 4]
```

知道为什么输出是`[2, 4]`吗？

#### :bulb: 解释:

* 首先，我是不赞成在迭代的过程中修改迭代参数的（就像上面例子里那样）。正确的方法应该是先把迭代的列表拷贝一份，拿拷贝后的列表做迭代，就像上面第三个迭代做的那样（`list_3[:]`）。

     ```py
     >>> some_list = [1, 2, 3, 4]
     >>> id(some_list)
     139798789457608
     >>> id(some_list[:]) # 注意如果用切片法的话，Python会新建一个list对象。
     139798779601192
     ```


**`del`,`remove`和`pop`的区别：**
* `del var_name` 只会移除本地或者全局命名空间中对`var_name`这个变量的绑定（这就是为什么`list_1`迭代后没有任何改变，因为`list_1`这个变量并没有收到影响）。
* `remove` 会根据值(value)进行匹配并移除第一个匹配上的元素，若没有匹配的元素则抛出`ValueError`异常。
* `pop` 会移除指定索引(index)的元素并且返回这个元素，如果指定的元素不存在则抛出`IndexError`异常。

**所以为什么会输出`[2, 4]`呢？**
- 首先列表迭代是根据索引值一个一个迭代的，所以当我们把`1`这个元素从`list_2`或者`list_4`中移除了以后，这两个列表就变成了`[2, 3, 4]`。剩下的这几个元素会依次向左移填补刚刚删除了的元素的位置，也就是说，`2`这个元素现在的索引值(index)变成了0，`3`的索引值变成了1。接着在下次迭代的时候，`for`循环访问的索引值已经变成了1（也就是列表里`3`这个元素），所以`2`这个元素就被跳过去（没有删除）。同样的情况每迭代一次都会发生一次。

---